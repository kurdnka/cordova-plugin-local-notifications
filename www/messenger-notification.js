// Generated by CoffeeScript 1.8.0
(function() {
  var EventEmitter, MessengerNotification, Utils,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Utils = (function() {
    function Utils() {}


    /**
    Remove all items from array that are satisfying the supplied condition function.
    @param {Function} condition Callback called with one param - item. Called for each item to evaluate
        wich items to remove. Should return true on item we want to remove.
        If undefined or null, then remove all items.
    @param {Function} afterRemove Callback called on each removed item. Called after the item was removed.
        Three params: removed item, its original index, and new array (not containing the item)
    @param {Function} beforeRemove Callback called on each removed item. Called before the item remove.
        Three params: removed item, its index, and array (before removal)
    @return {number} Number of removed items
     */

    Utils.removeAll = function(array, condition, afterRemove, beforeRemove) {
      var i, item, toRemove, _i, _j, _len, _len1;
      Utils.checkArgs('aFF', 'removeAll()', arguments);
      if (condition == null) {
        condition = function() {
          return true;
        };
      }
      toRemove = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        if (condition(item)) {
          toRemove.push(item);
        }
      }
      for (_j = 0, _len1 = toRemove.length; _j < _len1; _j++) {
        item = toRemove[_j];
        i = array.indexOf(item);
        if (typeof beforeRemove === "function") {
          beforeRemove(item, i, array);
        }
        array.splice(i, 1);
        if (typeof afterRemove === "function") {
          afterRemove(item, i, array);
        }
      }
      return toRemove.length;
    };


    /**
    @param {string} types String containing letters for desired types
        's' - string
        'n' - number
        'f' - function
        'b' - boolean
        'o' - object
        'u' - undefined
        '0' - null (zero symbol)
    
        'a' - array
        '?' - defined
        '.' - dont care
    
        Capital letter variants - can be also undefined/null
     */

    Utils.checkArgs = function(types, funcName, args) {
      var arg, index, ret, type, _i, _len;
      for (index = _i = 0, _len = types.length; _i < _len; index = ++_i) {
        type = types[index];
        arg = args[index];
        ret = (function() {
          switch (type.toLowerCase()) {
            case 's':
              return typeof arg === typeof '';
            case 'n':
              return typeof arg === typeof 0;
            case 'f':
              return typeof arg === typeof (function() {});
            case 'b':
              return typeof arg === typeof true;
            case 'o':
              return typeof arg === typeof {} && !Utils.typeIsArray(arg);
            case 'u':
              return typeof arg === typeof void 0;
            case '0':
              return typeof arg === typeof null;
            case 'a':
              return Utils.typeIsArray(arg);
            case '?':
              return arg != null;
            case '.':
              return true;
            default:
              throw new Error("Type '" + type + "' not supported");
          }
        })();
        if (type !== '?' && type !== '0' && type === type.toUpperCase() && (arg == null)) {
          ret = true;
        }
        if (!ret) {
          throw new Error("" + funcName + " arg #" + index + " is of the wrong type ('" + (typeof arg) + "' instead of '" + type + "')");
        }
      }
      return true;
    };


    /**
    @returns {Boolean} true if supplied object is array
     */

    Utils.typeIsArray = Array.isArray || function(value) {
      return {}.toString.call(value) === '[object Array]';
    };

    return Utils;

  })();


  /**
  Class handling the events. Intendet to be used as base for extending other classes
   */

  EventEmitter = (function() {
    function EventEmitter() {}


    /**
    Register callback on events
    @param {String} events Whitespace separated names of events
    @param {Function} callback Callback registred on the events
    @param {Object} cbThis Pointer to object that will be passed as 'this' to event callback
     */

    EventEmitter.prototype.on = function(events, callback, cbThis) {
      var event, eventList, _i, _len;
      Utils.checkArgs('sf', 'EventEmitter.on()', arguments);
      eventList = this._getEvents(events);
      for (_i = 0, _len = eventList.length; _i < _len; _i++) {
        event = eventList[_i];
        this._addCallback(event, callback, cbThis);
      }
      return this;
    };


    /**
    Unregister callbac on events
    @param {String} events Whitespace separated names of events
    @param {Function} callback Callback unregistred off the events
     */

    EventEmitter.prototype.off = function(events, callback) {
      var event, eventList, _i, _len;
      Utils.checkArgs('sf', 'EventEmitter.off()', arguments);
      eventList = this._getEvents(events);
      for (_i = 0, _len = eventList.length; _i < _len; _i++) {
        event = eventList[_i];
        this._removeCallback(event, callback);
      }
      return this;
    };


    /**
    Fire events with arguments
    @param {String} events Whitespace separated names of events
    @param {arguments} args... Variable number of arguments that will be passed to callback as arguments
     */

    EventEmitter.prototype.fire = function() {
      var args, event, eventList, events, _i, _len;
      events = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      Utils.checkArgs('s', 'EventEmitter.fire()', arguments);
      eventList = this._getEvents(events);
      for (_i = 0, _len = eventList.length; _i < _len; _i++) {
        event = eventList[_i];
        this._callCallbacks(event, args);
      }
      return this;
    };


    /**
    Parse string containing whitespace-separated event names and return array with individual event names
    @param {String} eventsString Whitespace separated names of events
     */

    EventEmitter.prototype._getEvents = function(eventsString) {
      return eventsString.split(/\s+/);
    };


    /**
    Add callback to event
    @param {String} event Name of event for callbac to register to
    @param {Function} callback Callback we are registering to the event
    @param {Object} cbThis Pointer to object that will be passed as 'this' to event callback
     */

    EventEmitter.prototype._addCallback = function(event, callback, cbThis) {
      if (this.listeners == null) {
        this.listeners = {};
      }
      if (!this.listeners.hasOwnProperty(event)) {
        this.listeners[event] = [];
      }
      return this.listeners[event].push({
        func: callback,
        self: cbThis
      });
    };


    /**
    Remove callback from event. If callback is registered to the event multiple times, it will remove all of them.
    @param {String} event Name of the event
    @param {Function} callback Callback we are unregistering
     */

    EventEmitter.prototype._removeCallback = function(event, callback) {
      if (this.listeners == null) {
        return;
      }
      if (!this.listeners.hasOwnProperty(event)) {
        return;
      }
      return Utils.removeAll(this.listeners[event], function(item) {
        return item.func === callback;
      });
    };


    /**
    Call all listeners for given event. Call with 'self' object passed as 'this' pointer and array 'args' as arguments.
    @param {String} event Name of the event
    @param {Object} self Pointer to object that will be passed as 'this' to event callback
    @param {Array} args Array of arguments that will be passed to callback as arguments
     */

    EventEmitter.prototype._callCallbacks = function(event, args) {
      var callback, err, listener, self, _i, _len, _ref, _results;
      if (this.listeners == null) {
        return;
      }
      if (!this.listeners.hasOwnProperty(event)) {
        return;
      }
      _ref = this.listeners[event];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        listener = _ref[_i];
        self = listener.self;
        callback = listener.func;
        try {
          _results.push(callback.apply(self, args));
        } catch (_error) {
          err = _error;
          _results.push(console.error(err.stack));
        }
      }
      return _results;
    };

    return EventEmitter;

  })();


  /**
  start method must be called right after the application is ready
  otherwise the plugin won't fire any events
   */

  MessengerNotification = (function(_super) {
    __extends(MessengerNotification, _super);

    function MessengerNotification() {
      return MessengerNotification.__super__.constructor.apply(this, arguments);
    }


    /**
    This methods tells the plugin that application is ready to receive
    events from the plugin. If any event (notification click) has occured 
    while the app was not running, it will wait in a queue till this call.
     */

    MessengerNotification.prototype.start = function() {
      return cordova.exec(null, null, 'MessengerNotification', 'start', []);
    };


    /**
    Add a new entry to the registry
    @param {Object} options The notification properties
     */

    MessengerNotification.prototype.add = function(options) {
      return cordova.exec(null, null, 'MessengerNotification', 'add', [options]);
    };


    /**
    Cancels the specified notification
    @param {Object} options Tag of the notification ('messages', 'waypoints', ...)
     */

    MessengerNotification.prototype.cancel = function(tag) {
      return cordova.exec(null, null, 'MessengerNotification', 'cancel', [tag]);
    };


    /**
    Removes all previously registered notifications.
     */

    MessengerNotification.prototype.canceAll = function() {
      return cordova.exec(null, null, 'MessengerNotification', 'cancelAll', []);
    };

    return MessengerNotification;

  })(EventEmitter);

  module.exports = new MessengerNotification();

}).call(this);
